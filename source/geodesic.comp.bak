#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) writeonly uniform image2D outImage;

layout(std140, binding = 1) uniform Camera {
    vec3 camPos;     float _pad0;
    vec3 camRight;   float _pad1;
    vec3 camUp;      float _pad2;
    vec3 camForward; float _pad3;
    float tanHalfFov;
    float aspect;
    bool moving;
    int   _pad4;
} cam;

// Standard Physics Constants (Natural Units: G=c=M=1)
// We normalize distance so Rs = 2.0.
const float PI = 3.14159265359;
const float BLACK_HOLE_MASS = 1.0; 
const float RS = 2.0 * BLACK_HOLE_MASS; 

// SPIN PARAMETER 'a' (0.0 = Schwarzschild, 0.998 = Maximal Kerr)
// PhD Note: a = J / M. Max is 1.0. 
const float SPIN = 0.94; 
const float SPIN_SQ = SPIN * SPIN;

// Simulation settings
const float STEP_SIZE = 0.05; 
const int MAX_STEPS = 2500;
const float ESCAPE_R = 50.0; // In normalized units

// Globals for hit testing
vec3 hitColor = vec3(0.0);
float hitAlpha = 0.0;

// State vector for Hamiltonian integration: 
// [r, theta, phi, p_r, p_theta, p_phi]
// Note: p_t is conserved (-Energy), so we don't integrate it.
struct Geodesic {
    float r;
    float theta;
    float phi;
    float pr;
    float ptheta;
    float pphi; // Conserved Lz
    float E;    // Conserved Energy (-pt)
    float Q;    // Carter Constant (optional explicit tracking)
};

// --- KERR METRIC HELPERS ---

// Metric sigma: Σ = r^2 + a^2 cos^2(theta)
float getSigma(float r, float theta) {
    float cosT = cos(theta);
    return r*r + SPIN_SQ * cosT*cosT;
}

// Metric delta: Δ = r^2 - 2Mr + a^2
float getDelta(float r) {
    return r*r - 2.0*BLACK_HOLE_MASS*r + SPIN_SQ;
}

// Calculate 4-velocity of a photon from canonical momenta
// Returns dr/dlambda, dtheta/dlambda, dphi/dlambda
void getDerivatives(in Geodesic g, out float dr, out float dtheta, out float dphi, out float dpr, out float dptheta) {
    float sigma = getSigma(g.r, g.theta);
    float delta = getDelta(g.r);
    float sinT = sin(g.theta);
    float cosT = cos(g.theta);
    float sin2 = sinT*sinT;
    float cos2 = cosT*cosT;
    
    // Hamiltonian H = 1/2 * g^uv * p_u * p_v = 0 (Null Geodesic)
    // We derive Hamilton's equations: dot(x) = dH/dp, dot(p) = -dH/dx
    
    // Auxiliary terms to simplify math (from standard Kerr Hamiltonian)
    float R_term = (g.r*g.r + SPIN_SQ) * g.E - SPIN * g.pphi;
    float U_term = g.pphi / sinT - SPIN * g.E * sinT; // Actually simplified in most Hamiltonians
    
    // 1. Coordinate velocities (dx/dlambda)
    // dot(r) = (Delta / Sigma) * p_r
    dr = (delta / sigma) * g.pr;
    
    // dot(theta) = (1 / Sigma) * p_theta
    dtheta = (1.0 / sigma) * g.ptheta;
    
    // dot(phi) = ... (standard Boyer-Lindquist form)
    // Using H derivative: dH/dp_phi
    // This form is derived from g^phi_mu p_mu
    float term1 = (SPIN / (delta * sigma)) * R_term;
    float term2 = (1.0 / (sigma * sin2)) * (g.pphi - SPIN * g.E * sin2); // Corrected term
    dphi = term1 + term2;
    
    // 2. Momentum derivatives (dp/dlambda = -dH/dx)
    
    // dot(p_r) = -dH/dr
    // This is the nastiest part. Using analytical gradient of the Hamiltonian H.
    // H_reduced = (Delta p_r^2 + p_theta^2 + V_r + V_theta) / (2 Sigma)
    // It's often easier to compute gradients numerically or use the separated constants.
    // Explicit derivative for stability:
    
    // Derivative of Delta/Sigma * p_r^2 is handled partially above. 
    // Let's use the explicit second order Geodesic equations reduced to first order
    // Or simply differentiating the Hamiltonian components.
    
    // Simpler approach for GLSL: Numerical differentiation of Hamiltonian H 
    // OR precise analytic forms. Let's use the analytic forms from "Numerical Recipes in Relativity".
    
    float dDelta_dr = 2.0*g.r - 2.0*BLACK_HOLE_MASS;
    float dSigma_dr = 2.0*g.r;
    float dSigma_dth = -2.0*SPIN_SQ * sinT * cosT;
    
    // Reconstruct T-component for H calculation context
    float P_val = (g.r*g.r + SPIN_SQ)*g.E - SPIN*g.pphi;
    
    // dH/dr term
    // H = 0 constraint is used.
    // dot(p_r) = -1/(2 Sigma^2) * dSigma/dr * (H_numerator) + 1/(2 Sigma) * d(H_numerator)/dr
    // Since H=0, the first term vanishes? No, H=0 on the path, but the field H defines gradients.
    // Actually, we can't assume H=0 for derivatives.
    // Let's rely on the explicit forces:
    
    // Radial Force
    float numer_r = - (dDelta_dr * g.pr * g.pr) 
                    + 2.0 * g.r * ((g.r*g.r+SPIN_SQ)*g.E - SPIN*g.pphi) * (2.0*g.E*g.r) / delta // Chain rule mess
                    - (dDelta_dr * P_val * P_val) / (delta*delta); // Very error prone
                    
    // Alternate PhD Approach: Use the Carter Constant K separation directly? 
    // No, RK4 is better for general rendering.
    
    // Let's implement the specific Kerr derivatives:
    // Reference: "Geodesic Motion in Kerr Spacetime", standard forms.
    // dp_r/dlam = ...
    // This is often too complex for concise GLSL. 
    // We will use a robust approximation: The Hamiltonian Gradient Method.
    
    // H = 0.5/Sigma * ( Delta*pr^2 + pth^2 - (P^2)/Delta + (pphi/sin - a*E*sin)^2 )
    // We compute gradients of H w.r.t r and theta numerically (Finite Difference). 
    // It's extremely cheap in a shader and mathematically exact enough for double precision, 
    // though floats might be noisy. Let's try analytic for r.
    
    // Analytic dH/dr:
    float dH_dr = - (dSigma_dr / (2.0*sigma*sigma)) * ( delta*g.pr*g.pr + g.ptheta*g.ptheta - (P_val*P_val)/delta + pow(g.pphi/sinT - SPIN*g.E*sinT, 2.0) )
                  + (1.0 / (2.0*sigma)) * ( dDelta_dr*g.pr*g.pr 
                                          - (2.0*P_val * (2.0*g.r*g.E) * delta - P_val*P_val*dDelta_dr) / (delta*delta) );
                                          // Last term (theta part) has no r dependence.
                                          
    dpr = -dH_dr;

    // Analytic dH/dtheta:
    float termTheta = pow(g.pphi/sinT - SPIN*g.E*sinT, 2.0);
    float dTermTheta_dth = 2.0 * (g.pphi/sinT - SPIN*g.E*sinT) * ( -g.pphi*cosT/(sinT*sinT) - SPIN*g.E*cosT );
    
    float dH_dth = - (dSigma_dth / (2.0*sigma*sigma)) * ( delta*g.pr*g.pr + g.ptheta*g.ptheta - (P_val*P_val)/delta + termTheta )
                   + (1.0 / (2.0*sigma)) * ( dTermTheta_dth ); 
    
    dptheta = -dH_dth;
}

// 4th Order Runge-Kutta Integrator
void rk4Step(inout Geodesic g, float h) {
    float k1_r, k1_th, k1_ph, k1_pr, k1_pth;
    getDerivatives(g, k1_r, k1_th, k1_ph, k1_pr, k1_pth);
    
    Geodesic g2 = g;
    g2.r += 0.5*h*k1_r; g2.theta += 0.5*h*k1_th; g2.pr += 0.5*h*k1_pr; g2.ptheta += 0.5*h*k1_pth;
    float k2_r, k2_th, k2_ph, k2_pr, k2_pth;
    getDerivatives(g2, k2_r, k2_th, k2_ph, k2_pr, k2_pth);

    Geodesic g3 = g;
    g3.r += 0.5*h*k2_r; g3.theta += 0.5*h*k2_th; g3.pr += 0.5*h*k2_pr; g3.ptheta += 0.5*h*k2_pth;
    float k3_r, k3_th, k3_ph, k3_pr, k3_pth;
    getDerivatives(g3, k3_r, k3_th, k3_ph, k3_pr, k3_pth);

    Geodesic g4 = g;
    g4.r += h*k3_r; g4.theta += h*k3_th; g4.pr += h*k3_pr; g4.ptheta += h*k3_pth;
    float k4_r, k4_th, k4_ph, k4_pr, k4_pth;
    getDerivatives(g4, k4_r, k4_th, k4_ph, k4_pr, k4_pth);

    g.r      += (h/6.0) * (k1_r + 2*k2_r + 2*k3_r + k4_r);
    g.theta  += (h/6.0) * (k1_th + 2*k2_th + 2*k3_th + k4_th);
    g.phi    += (h/6.0) * (k1_ph + 2*k2_ph + 2*k3_ph + k4_ph);
    g.pr     += (h/6.0) * (k1_pr + 2*k2_pr + 2*k3_pr + k4_pr);
    g.ptheta += (h/6.0) * (k1_pth + 2*k2_pth + 2*k3_pth + k4_pth);
}

// Convert Camera Ray to Initial Geodesic State (Boyer-Lindquist)
Geodesic initGeodesic(vec3 camPos, vec3 dir) {
    Geodesic g;
    
    // 1. Position Conversion (Cartesian -> BL Spherical)
    // Note: User cam is in physical coords. We normalize to RS=2 units.
    float normScale = 1.269e10 / 2.0; // SagA_rs / 2
    vec3 pos = camPos / normScale;
    
    float r = length(pos);
    float theta = acos(pos.y / r); // Assume Y is UP in setup
    float phi = atan(pos.z, pos.x);
    
    g.r = r;
    g.theta = theta;
    g.phi = phi;
    
    // 2. Momentum Initialization
    // We need to project the camera direction 'dir' into the local tetrad 
    // and then to BL coordinate basis. 
    // Simplified: Standard flat-space projection for camera far away (Minkowski limit).
    // In BL at large r: pr = dr/dl, pth = r*dth/dl, pphi = r*sinT*dphi/dl
    
    // Rotate dir to align with spherical basis vectors at camera pos
    vec3 basis_r = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi)); // Y-up conv
    vec3 basis_th = vec3(cos(theta)*cos(phi), -sin(theta), cos(theta)*sin(phi));
    vec3 basis_ph = vec3(-sin(phi), 0.0, cos(phi));
    
    // Project direction onto basis
    float dr = dot(dir, basis_r);
    float dth = dot(dir, basis_th) / r;
    float dph = dot(dir, basis_ph) / (r * sin(theta));
    
    // Metric at camera (assuming Schwarzschild-like at distance for initial P)
    // For exactness, we should use full Kerr metric inverse at camera, 
    // but assuming camera is far (>50 Rs), flat space approximation is OK.
    
    g.pr = dr;       // approx p_r
    g.ptheta = r * dot(dir, basis_th); // p_theta
    g.pphi = r * sin(theta) * r * sin(theta) * dph; // p_phi = Lz
    g.E = 1.0; // Normalize photon energy to 1
    
    // Refine E to ensure Null Geodesic (H=0) at start?
    // H = 0 -> solve for p_t (which is -E). 
    // In flat space E^2 = pr^2 + pth^2/r^2 + pphi^2/(r sin th)^2. 
    // Our setup above satisfies this naturally.
    
    return g;
}

// --- RELATIVISTIC DISK SHADING ---
// Returns color of accretion disk with Doppler beaming
vec3 getDiskColor(Geodesic g) {
    // 1. Check intersection
    // Disk is at theta = PI/2 (Equatorial plane)
    // We check if we crossed PI/2 in the last step.
    // Done in main loop. Here we calculate color.
    
    float r = g.r;
    if (r < 2.6 || r > 12.0) return vec3(0.0); // Disk limits in Rs units
    
    // 2. Texture / Intrinsic Color (Blackbody-ish)
    float temp = 1.0 / sqrt(r); 
    vec3 baseColor = vec3(1.0, 0.8, 0.6) * temp * 2.0;
    
    // 3. Relativistic Velocity of Disk Material (Keplerian)
    // Angular velocity Omega = 1 / (a + r^3/2)
    float omega = 1.0 / (SPIN + pow(r, 1.5));
    
    // 4-Velocity of emitter u_e = u^t (1, 0, 0, Omega)
    // u^t = 1 / sqrt( -g_tt - 2 Omega g_tph - Omega^2 g_phph )
    float delta = getDelta(r);
    float sigma = r*r; // theta=pi/2
    // Metric components at equator:
    float g_tt = -(1.0 - 2.0*r/sigma);
    float g_tph = -2.0*r*SPIN/sigma;
    float g_phph = (sigma*sigma + SPIN_SQ*r*r + 2.0*SPIN_SQ*r)/sigma; // approx
    // Simplified metric at equator:
    // ds^2 = - (1 - 2/r) dt^2 - (4a/r) dt dphi + (r^2 + a^2 + 2a^2/r) dphi^2 + ...
    
    // Let's use the redshift factor g = E_emit / E_obs
    // g = sqrt( 1 - 2/r ) / ( 1 + Omega * L/E ) ?? 
    // Precise formula: g = ( p_t + Omega * p_phi ) / ( p_t_cam ) ... no.
    
    // Standard Formula: g = 1 / ( u^t ( 1 - Omega * b ) ) where b = impact parameter L/E
    // Let's go raw 4-vector dot product:
    // g = (p . u_obs) / (p . u_emit)
    // Obs is at infinity static: p.u_obs = p_t = -E = -1.
    // Emitter: p.u_emit = p_t u^t + p_phi u^phi = u^t ( -E + Omega * L )
    
    float ut_denom = 1.0 - 2.0/r - 4.0*SPIN*omega/r + (r*r + SPIN_SQ + 2.0*SPIN_SQ/r)*omega*omega;
    float ut = 1.0 / sqrt(ut_denom);
    
    float shift = (-g.E + omega * g.pphi) * ut;
    // shift is (E_emit). E_obs is 1. 
    // So ratio is 1 / shift.
    // Actually, redshift z = E_emit/E_obs - 1.
    // Doppler factor D = E_obs / E_emit = 1 / shift.
    
    float doppler = 1.0 / abs(shift); // abs to prevent negative energy glitches
    
    // 4. Beam Modulation: I_obs = D^4 * I_emit
    float intensity = pow(doppler, 4.0);
    
    return baseColor * intensity;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outImage);
    if (pix.x >= size.x || pix.y >= size.y) return;

    // Camera setup (standard ray gen)
    float u = (2.0 * (pix.x + 0.5) / size.x - 1.0) * cam.aspect * cam.tanHalfFov;
    float v = (1.0 - 2.0 * (pix.y + 0.5) / size.y) * cam.tanHalfFov;
    vec3 dir = normalize(u * cam.camRight - v * cam.camUp + cam.camForward);
    
    Geodesic ray = initGeodesic(cam.camPos, dir);
    
    vec3 finalColor = vec3(0.0);
    bool hit = false;
    
    float prevTheta = ray.theta;
    
    for (int i = 0; i < MAX_STEPS; ++i) {
        // Runge Kutta Step
        rk4Step(ray, STEP_SIZE);
        
        // Event Horizon Check
        float rH = 1.0 + sqrt(1.0 - SPIN_SQ); // Outer horizon
        if (ray.r < rH + 0.05) {
            finalColor = vec3(0.0); // Shadow
            hit = true;
            break;
        }
        
        // Disk Intersection Check (Crossing the Equatorial Plane)
        // Check if theta crossed PI/2
        if ((ray.theta - PI/2.0) * (prevTheta - PI/2.0) < 0.0) {
            // Refine intersection? (Linear interpolation) - Optional optimization
            // For now, just render if within radius
            vec3 diskCol = getDiskColor(ray);
            if (length(diskCol) > 0.01) {
                finalColor += diskCol; // Additive blend (or alpha blend)
                // If disk is opaque:
                hit = true;
                break;
            }
        }
        prevTheta = ray.theta;
        
        if (ray.r > ESCAPE_R) {
            // Sample background (skybox) here if you have one
            // Use ray direction at infinity: (pr, ptheta, pphi) mapped to cartesian
            finalColor = vec3(0.05); // Starry background placeholder
            break;
        }
    }
    
    imageStore(outImage, pix, vec4(finalColor, 1.0));
}
